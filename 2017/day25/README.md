### CMDB后台管理
- 资产列表(CURD)
- 业务线列表(CURD)
- 用户列表(CURD)
- 组列表(CURD)
- ...

公共组建: 删改查(models.py)

* 查:
        资产列表

        配置文件: key代指查询条件, value为查询表的列名
        config = [
            {'q': 'id'},
            {'q': 'name'},
            ]
        --------
        values_list = ['id', name] 作为column传入下方查询参数
        查询:
            querySet = model.TB.objects.filter([condition]).values([column name])[start, end]
                --> [{},{},{}]

            querySet = model.TB.objects.filter([condition]).values(*values_list)

        标配: 配置 + 数据库操作

* 前端插件定制表结构

        定制td内容以及属性

        参考 app01/views.py ServerView, ServerJsonView

        前端插件开发流程:
            1. 开发表格配置文件, 基类
                   table_config 表格配置
                   condition_config 条件配置 用于页面显示过滤器
            2. 拷贝html页面
            3. RESTful 接口操作数据库并返回



* Django 静态资源浏览器缓存与服务器端不一致问题

        1. 在url后面加问号 可以在url相同的情况下对资源进行刷新请求,从而更新浏览器缓存的静态资源
        2. 加?time=时间戳
        3. 使用md5维护服务器静态资源:
            参考:http://blog.thehumangeo.com/2013/05/01/dynamically-cache-static-files-using-django-and-nginx/
                https://www.zhihu.com/question/20790576



### Base Algorithm

> 算法(Algorithm) 一个计算过程 解决问题的方法

1. 递归

        调用自身
        结束条件
        def func(x)
            if x > 0
                # print(x)  # 5 4 3 2 1
                func(x - 1)
                print(x)  # 1 2 3 4 5

        尾递归与尾递归优化

        递归在通常情况下是比循环慢的 如果不在最后一行执行递归的话, 还会持有上一次递归的上下文
            导致内存溢出, 为解决溢出问题, 可以使用位递归, 即在最后一行执行递归, 且递归函数不持有上次递归的上下文
            为解决慢的问题 可以return 递归函数

2. 复杂度

        时间复杂度

            时间复杂度是用来估计算法运行时间的一个式子(单位)

            一般来说 时间复杂度高的算法比时间复杂度低的算法跑的慢 O(1) < O(log n) < O(n) < O(n * log n) < O(n^2) < O(n^2 * log n) < O(n^3)
            O(1)是常数复杂度

            不常见的时间复杂度:
            O(n!) O(2^n) O(n^n) 时间复杂度都很大

            循环减一般 就是log
            几层循环 就是n的几次方


        空间复杂度

            用来评估算法内存占用大小的一个式子

            "空间换时间"



        列表查找

                从列表中查找指定元素
                    输入: 列表|待查找元素
                    输出: 元素下标|"未查找到元素"


                顺序查找:
                    从列表第一个元素开始, 顺序进行搜索 直到找到为止

                二分查找
                    从有序列表的候选区data[0:n]开始, 通过对待查找的值与候选区的中间值比较, 可以使候选区减少一半


                    def binary_search(data_list, val):
                        low = 0
                        high = len(data_list) - 1
                        while low <= high:
                            mid = (low + high) // 2  # 整除
                            if data_list[mid] == val:
                                return mid
                            elif data_list[mid] < val:
                                low = mid + 1
                            else:
                                high = mid - 1

                        return "can not find index in list"

3. 排序

    * 列表排序
        - 将无序列表变为有序列表

    * 应用场景
        - 各种榜单
        - 各种表格
        - 给二分查找用
        - 给其他算法用

    * 输入:无序列表 输出:有序列表
    * 关键点
        - 有序区
        - 无序区
    * 种类:

        - 冒泡排序 O(n^2)
        - 选择排序 O(n^2)
        - 插入排序 O(n^2)

        - 快速排序 O(n log n)

            > 一般系统api使用的排序都是快速排序 python中sys的sort比快速排序快一个数量集 原因是系统的sort函数是调用c的排序

        - 堆排序
        - 归并排序

        - 基数排序
        - 希尔排序
        - 桶排序

    * 效率
        ```
        快速排序真的比冒泡排序快吗
            一般情况下是快了
            但是当逆序列表变正序时 递归层级巨大 每次插入中间值都需要执行递归
            此时速度比冒泡排序慢 时间复杂度为O(n^2)
        为什么快了?
            冒泡排序时间复杂度是O(n^2)
            快速排序时间复杂度是O(n*log n)
        快了多少?
            参考cost_time

        问题
            最坏情况
                逆序列表变正序 当超过一定递归层级 递归会造成溢出
                解决方式
                    # 设置递归最大层级
                    sys.setrecursionlimit(10000)
        ```

    * 堆排序
        1. 树与二叉树

                树是一种目录结构

        2. 树是一种可以递归定义的数据结构

        3. 树是由n个节点组成的集合
            - 如果n = 0 那这是一个空树
            - 如果n > 0 那存在一个节点作为树的根节点, 其他节点可以分为m个集合 每个集合本身又是一棵树

        4. 一些概念
            - 根节点 叶子节点
            - 树的深度 (高度)
            - 树的度
            - 孩子节点/父节点
            - 子树

        5. 满二叉树与完全二叉树

            (完全)二叉树可以用列表来存储 通过规律可以从父亲找到孩子或从孩子找到父亲
            ```
            二叉树: 度为2的树
            满二叉树: 每一个父节点都有两个子节点
            完全二叉树: 最后一层左右节点可以不满 但最后一层中间父节点都有子节点且其他层节点完整的二叉树叫做完全二叉树
            ```
        6. 二叉树存储方式
            ```
            1. 链式存储方式
                从根节点开始 每层从左孩子向右孩子存储
            2. 顺序存储方式

            3. 父节点和左孩子节点编号下标有什么关系?
                0-1 1-3 2-5 3-7 4-9
                i ~ 2i +1
            4. 父节点和右孩子节点编号下标有什么关系?
                i ~ 2i +2

            ```
        7. 堆 是一种特殊的完全二叉树
            - 大根堆: 一颗完全二叉树, 满足任意节点都比其孩子节点大
            - 小根堆: 一颗完全二叉树, 满足任意节点都比起孩子节点小

        8. 堆排序过程

                1. 建立堆
                2. 得到堆顶元素 为最大元素
                3. 去掉堆顶 将堆最后一个元素放到堆顶 此时可通过一次调整重新使堆有序
                4. 堆顶元素为第二大元素
                5. 重复步骤3 直到堆变空

        9. 归并排序

                假设现在的列表分两段有序, 如何将其合成为一个有序列表

                    取两段有序列表 从最小值一一比较排序
                    逐个取出最小的值 放置到一个新的列表中

                这种操作称为一次归并

                归并排序过程

                    分解: 将列表越分越小 直至分成一个元素
                    一个元素是有序的
                    合并: 将两个有序列表归并, 列表越来越大

   * 小结:

            快速排序 堆排序 归并排序算法的时间复杂度都是O(n log n)
            一般情况下 就运行时间而言:
                快速排序 < 归并排序 < 堆排序

            三种排序算法的缺点

            快速排序: 极端情况下排序效率低
            归并排序: 需要额外的内存开销
            堆排序: 在快的排序算法中相对较慢


   * 希尔排序

            时间复杂度 O(1.3n)
            希尔排序是一种分组插入的排序算法
            首先取一个整数 d1 = len / 2, 将元素分为d1个组, 每组相邻两元素之间距离为d1, 在各组内进行直接插入排序

            取第二个整数d2 = d1 / 2, 重复上述分组排序过程, 直到di = 1, 即所有元素在同一组内进行直接插入排序

            希尔排序每趟并不使某些元素有序, 而是使整体数据越来越接近有序, 最后一趟排序使得所有数据有序


   * 自定义排序

            需要有限制条件 在限制条件下 排序的时间复杂度能够达到O(n)


   * 堆的应用

            优先队列: 一些元素的集合, POP操作每次执行都会优先从队列中
            弹出最大(大根堆) 或最小(小根堆)的元素

            堆: 优先队列

            python 内置模块-- heapq

                heappush(heap, value): 向堆中添加一个值 并重新调整
                heappop(heap, value): 从根的位置弹出一个值 并重新调整
                nlargest(n, iterable, key=None): 按从大到小的顺序 输出长度为n的有序列表
                nsmallest(n, iterable, key=None): 按从小到大的顺序 输出长度为n的有序列表

                利用heapq模块实现堆排序
                参考: heapq_sort.py

                利用heapq模块实现排行榜 取前多少位


4. 数据结构

    * 什么是数据结构?

            简单来说, 数据结构就是设计数据以何种方式组织并存储在计算机中
            比如: 列表\集合与字典等都是一种数据结构

            N.Wirth: "程序=数据结构+算法"














