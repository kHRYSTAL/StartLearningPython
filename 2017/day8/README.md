### 协程

    协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的轻量级线程。

    协程拥有自己的[寄存器上下文和栈](CPU只知道线程 线程的上下文和栈在CPU的寄存器上, 并不知道协程)。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：

    协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。

    简而言之 就是如果一个函数使用协程 可以随时的跳出函数执行其他, 然后再跳入函数
    从而实现在单线程上执行类似多线程的并行操作

    协程的好处：

        无需线程上下文切换的开销
        无需原子操作锁定及同步的开销
        　　"原子操作(atomic operation)是不需要synchronized"，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序是不可以被打乱，或者切割掉只执行部分。视作整体是原子性的核心。
        方便切换控制流，简化编程模型
        高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。

    缺点：

        无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。
        进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序

### 异步IO（asyncio）

    在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。
    在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。
    因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。
    多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。
    由于我们要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配，多线程和多进程只是解决这一问题的一种方法。
    另一种解决IO问题的方法是异步IO。当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。

    在Android中 所有的io操作都是同步的 所以需要开辟线程
    也就是说,python的协程遇到耗时操作(io操作)就跳出函数 执行其他函数 等待io结果返回在执行
    而Android中没有协程的概念 只能开辟线程 等待回调结果


### greenlet 已经封装好的协程库 不需要再去写yield

    为什么是green? 协程又叫greenthread 即线程无切换开销 无阻塞 无需锁
    greenlet 封装了yield 手动切换生成器更方便

### gevent 基于greenlet封装 不需要再去手动切换



